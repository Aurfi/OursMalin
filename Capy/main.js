(() => {
  /**
   * FlappyÂ Capybara
   *
   * Ce fichier implÃ©mente la logique du jeu.  Il gÃ¨re lâ€™affichage du menu, le gameplay
   * (mouvement du capybara, gÃ©nÃ©ration des obstacles et bonus, dÃ©tection de collisions,
   * calcul du score et gestion des Ã©tats) ainsi que lâ€™Ã©cran de fin de partie.
   */

  const canvas = document.getElementById('gameCanvas');
  const ctx = canvas.getContext('2d');
  let width = canvas.width;
  let height = canvas.height;

  // Image du capybara pour le mode Flappy. Nous utilisons l'illustration
  // originale sans licorne ni ailes intÃ©grÃ©es afin de pouvoir dessiner
  // proprement des ailes animÃ©es par-dessus. Cette image est dÃ©tourÃ©e et
  // orientÃ©e vers la gauche par dÃ©fautÂ ; elle sera pivotÃ©e par le dessin.
  const capyImg = new Image();
  // Utiliser la nouvelle illustration fournie par l'utilisateur (fond transparent).
  // Cette image ne comporte pas d'ailes intÃ©grÃ©es afin de pouvoir dessiner nos
  // propres ailes animÃ©es.  Remplacer l'ancien fichier personnalisÃ© par
  // capybara_flying.png placÃ© dans assets.
  capyImg.src = 'assets/capybara_flying.png';

  // Image pour le sol du jeu.  Au lieu d'un simple dÃ©gradÃ© vert ou du motif
  // bambou, nous utilisons un dÃ©cor de marÃ©cage (swamp_background.png)
  // pour apporter une touche plus naturelle et moins monotone Ã  l'arriÃ¨re-plan.
  const groundImg = new Image();
  groundImg.src = 'assets/swamp_background.png';

  // Ã‰tats possibles du jeu
  const STATE_MENU = 'menu';
  const STATE_PLAYING = 'playing';
  const STATE_GAMEOVER = 'gameover';
  let state = STATE_MENU;

  // Lecture/Ã©criture du meilleur score via localStorage
  let highScore = 0;
  try {
    const stored = localStorage.getItem('flappyCapybaraHighScore');
    if (stored !== null) highScore = parseInt(stored, 10) || 0;
  } catch (e) {
    // localStorage peut Ãªtre dÃ©sactivÃ©, ignorer
    highScore = 0;
  }

  // RÃ©cupÃ©rer les records des autres modes pour afficher sur le menu principal.
  let runnerHighScore = 0;
  let energyHighScore = 0;
  try {
    const storedRunner = localStorage.getItem('capyRunnerHighScore');
    if (storedRunner !== null) runnerHighScore = parseInt(storedRunner, 10) || 0;
  } catch (e) {
    runnerHighScore = 0;
  }
  try {
    const storedEnergy = localStorage.getItem('capyElectricHighScore');
    if (storedEnergy !== null) energyHighScore = parseInt(storedEnergy, 10) || 0;
  } catch (e) {
    energyHighScore = 0;
  }

  // La mise Ã  jour des records sera effectuÃ©e plus bas dans le code, aprÃ¨s
  // l'initialisation des Ã©lÃ©ments DOM.  Cette ligne a Ã©tÃ© dÃ©placÃ©e afin
  // d'Ã©viter d'accÃ©der Ã  des constantes encore non initialisÃ©es (TDZ).

  // SÃ©lecteurs dâ€™interface
  const menuOverlay = document.getElementById('menu');
  const gameOverOverlay = document.getElementById('gameover');
  // Ã‰lÃ©ments d'interface pour afficher les meilleurs scores sur la page d'accueil.
  const bestScoreFlappyEl = document.getElementById('best-score-flappy');
  const bestScoreRunningEl = document.getElementById('best-score-running');
  // Le record pour le mode Ã©lectrique (anciennement vÃ©hicule) est stockÃ©
  // dans l'Ã©lÃ©ment dont l'ID a Ã©tÃ© mis Ã  jour sur la page d'accueil.
  const bestScoreEnergyEl = document.getElementById('best-score-electric');
  const currentScoreEl = document.getElementById('current-score');
  const highScoreEl = document.getElementById('high-score');
  const playBtn = document.getElementById('play-button');
  const replayBtn = document.getElementById('replay-button');
  const menuBtn = document.getElementById('menu-button');
  const runnerBtn = document.getElementById('runner-button');
  // Ã‰lÃ©ment pour message amusant sur l'Ã©cran de Game Over (affichÃ© seulement si prÃ©sent)
  const funMessageEl = document.getElementById('flappy-fun-message');

  // Liste de messages amusants et anecdotes sur le fromage pour varier les Ã©crans de fin
  // Liste de messages et anecdotes affichÃ©s alÃ©atoirement Ã  la fin de la partie.
  // Certaines entrÃ©es classiques ont Ã©tÃ© conservÃ©es mais la majoritÃ© ont
  // Ã©tÃ© renouvelÃ©es pour offrir plus de variÃ©tÃ© et dâ€™humour.  Les
  // nouveaux textes abordent des faits Ã©tonnants sur les capybaras et
  // des anecdotes fromagÃ¨res amusantes.
  const cheeseMessages = [
    // Quelques classiques
    "Saviezâ€‘vous que certaines meules de fromage peuvent peser plus de 100Â kgÂ ?",
    "Le Roquefort est affinÃ© dans des grottes naturelles du sud de la France depuis des siÃ¨cles.",
    "Il existe plus de 1Â 200 variÃ©tÃ©s de fromage en FranceÂ !",
    "Les capybaras sont parfois surnommÃ©s Â«Â les rois du chillÂ Â» car ils se prÃ©lassent avec nâ€™importe quel animal.",
    // Nouveaux messages
    "En Bolivie, les capybaras sont parfois appelÃ©s 'chanchitos de rÃ­o' â€“ petits cochons de riviÃ¨re.",
    "Le fromage Ã  tartiner a Ã©tÃ© inventÃ© par accident lorsquâ€™un fromage Ã  pÃ¢te molle fut trop chauffÃ©.",
    "Pourquoi le capybara est-il toujours Ã  lâ€™heureÂ ? Parce quâ€™il suit le courantÂ !",
    "Dans certains pays dâ€™Asie, on fait fermenter le fromage pendant des annÃ©es pour obtenir un goÃ»t puissant.",
    "Une famille de capybaras peut comprendre jusquâ€™Ã  20 individus, tous aussi relax.",
    "Certaines meules de parmesan sont marquÃ©es au feu pour garantir leur origine.",
    "Le saviez-vousÂ ? Le capybara communique en Ã©mettant de petits sifflements.",
    "Pourquoi les fromages font-ils de bons partisansÂ ? Parce quâ€™ils sont affinÃ©s avec le temps.",
    "Au BrÃ©sil, on peut voir des capybaras se prÃ©lasser dans les parcs urbains.",
    "Le fromage suisse Emmental est rÃ©putÃ© pour ses grands trous, appelÃ©s 'yeux'.",
    "Selon la lÃ©gende, un capybara aurait dÃ©jÃ  fait une sieste pendant un concert de rock.",
    "Certains fromages hollandais sont colorÃ©s en rouge avec de la cire pour les protÃ©ger.",
    "Le capybara est un excellent nageur grÃ¢ce Ã  ses doigts palmÃ©s.",
    "Pourquoi le camembert est-il romantiqueÂ ? Parce quâ€™il fond toujours pour vous.",
    "Les capybaras vivent souvent en harmonie avec des oiseaux perchÃ©s sur leur dos.",
    "Dans les Alpes, on fabrique de la raclette depuis le Moyen Ã‚ge.",
    "Le capybara peut dormir dans lâ€™eau, ne laissant dÃ©passer que son nez.",
    "La croÃ»te du fromage peut Ãªtre lavÃ©e Ã  la biÃ¨re pour dÃ©velopper des arÃ´mes uniques.",
    "Un capybara peut courir jusquâ€™Ã  35Â km/h sur de courtes distances.",
    "Pourquoi les fromages nâ€™aiment-ils pas les secretsÂ ? Parce quâ€™ils finissent toujours par fuirÂ !",
    "Certaines tribus dâ€™Amazonie considÃ¨rent le capybara comme un animal sacrÃ©.",
    "Le fromage bleu obtient sa couleur grÃ¢ce Ã  des cultures de moisissures spÃ©cifiques.",
    "Les capybaras sont parfois adoptÃ©s comme animaux de compagnie en AmÃ©rique du Sud.",
    "Pourquoi le cheddar aime les devinettesÂ ? Parce quâ€™il adore quâ€™on le dÃ©chiffreÂ !",
    "La feta grecque est traditionnellement fabriquÃ©e avec du lait de brebis.",
    "Le capybara chante parfois sous la pluie, un spectacle rare mais adorable.",
    "En NorvÃ¨ge, on fabrique un fromage brun sucrÃ© Ã  base de lactosÃ©rum, le 'brunost'.",
    "Pourquoi le gouda est-il optimisteÂ ? Parce quâ€™il voit toujours la meule Ã  moitiÃ© pleine.",
    "Les moustaches du capybara sont extrÃªmement sensibles et lâ€™aident Ã  dÃ©tecter des mouvements dans lâ€™eau.",
    "Le fromage halloumi peut Ãªtre grillÃ© sans fondre, parfait pour les barbecues.",
    "On dit que les capybaras rÃªvent de nÃ©nuphars gÃ©ants.",
    "Certaines caves Ã  fromage sont situÃ©es sous des monastÃ¨res centenaires.",
    "Les capybaras aiment se faire gratter le ventre, surtout au coucher du soleil.",
    "Le roquefort est affinÃ© dans les grottes de Combalou depuis plus de 1Â 000Â ans.",
    "Pourquoi le fromage de chÃ¨vre est-il drÃ´leÂ ? Parce quâ€™il a du 'chÃ©vreâ€‘sprit'Â !"
  ];

  // Messages satiriques lorsque le joueur obtient un score trÃ¨s bas (<10).
  const lowScoreMessages = [
    "On aurait pu faire une sieste et marquer davantage de pointsÂ !",
    "MÃªme un bÃ©bÃ© capybara aurait volÃ© plus loinâ€¦",
    "Ton score est si bas quâ€™il dÃ©prime les grenouilles du marais."
  ];
  // Visuels Ã  afficher alÃ©atoirement sur lâ€™Ã©cran de Game Over : seulement des animaux
  // SÃ©lection d'illustrations Ã  afficher alÃ©atoirement sur lâ€™Ã©cran de Game Over.
  // Afin de conserver une cohÃ©rence graphique, seules des capybaras sont
  // utilisÃ©es (pas de pingouin, de tortue ou de licorne).  Les images
  // suivantes reprÃ©sentent les diffÃ©rentes activitÃ©s du capybaraÂ : volant,
  // courant, bombardier, superhÃ©ros, mÃ©moire et blackjack.
  // Liste dâ€™illustrations Ã  afficher alÃ©atoirement sur lâ€™Ã©cran de Game Over.
  // Seules des capybaras mignonnes en gros plan sont conservÃ©es.  Les icÃ´nes
  // gÃ©nÃ©riques ou les images de jeux (mÃ©moire, blackjack, GIGNâ€¦) sont exclues.
  const funImages = [
    'assets/capybara_unicorn.png',
    'assets/capybara_turtle.png',
    'assets/capybara_penguin.png',
    'assets/capybara_bomber.png',
    'assets/capybara_super.png',
    'assets/capybara_ninja_new.png',
    'assets/capybara_electric.png',
    'assets/capybara_catch.png',
    'assets/capybara_running_new.png'
  ];
  // Bouton volume global
  const volumeBtn = document.getElementById('volume-toggle');
  if (volumeBtn) {
    volumeBtn.addEventListener('click', () => {
      isMuted = !isMuted;
      volumeBtn.textContent = isMuted ? 'ğŸ”‡' : 'ğŸ”Š';
      if (isMuted) {
        stopMusic();
      } else {
        startMusic();
      }
      applyVolume();
    });
  }
  // Supprimer la gestion d'un bouton sÃ©parÃ© pour la musique.  La page flappy ne
  // comporte qu'un seul contrÃ´le de volume, donc la variable musicBtn et son
  // Ã©vÃ©nement sont retirÃ©s.

  // ParamÃ¨tres du jeu
  // GravitÃ© et impulsion de sautÂ : ajustÃ©s pour rendre le jeu plus accessible.
  // GravitÃ© : valeur rÃ©duite pour ralentir la chute et rendre le vol plus facile
  // GravitÃ©Â : valeur rÃ©duite pour une chute plus lente et un contrÃ´le plus facile.  
  // Elle est volontairement faible pour permettre au capybara de planer longtemps aprÃ¨s un saut.
  const gravity = 0.04;
  // Impulsion de saut d'origine conservÃ©e comme rÃ©fÃ©rence.
  // Nous n'utilisons plus directement cette constante mais dÃ©finissons la
  // vÃ©locitÃ© dans jump().
  const jumpVelocity = -9.0;
  // Vitesse de dÃ©filement horizontal initiale.  La valeur origGameSpeed est
  // conservÃ©e pour pouvoir recalculer la vitesse effective lorsque
  // GLOBAL_SPEED_MULTIPLIER est mis Ã  jour.  Un ratio Ã©levÃ© rend le jeu
  // plus dynamique.
  // Augmenter la vitesse de dÃ©filement des obstacles pour rendre le jeu plus difficile.
  // La valeur d'origine Ã©tait de 1.6.  Nous l'augmentons afin que les obstacles
  // arrivent plus rapidement Ã  l'Ã©cran, rÃ©duisant ainsi le temps de rÃ©action du joueur.
  const origGameSpeed = 2.5;
  let gameSpeed = origGameSpeed;
  // Intervalle initial entre les obstacles.  Ce paramÃ¨tre est Ã©galement
  // recalculÃ© en fonction de la vitesse pour maintenir une densitÃ©
  // cohÃ©rente d'obstacles.  La valeur initiale est stockÃ©e dans
  // initialSpawnInterval.
  // Augmenter l'intervalle initial entre deux obstacles afin de garantir
  // des passages plus larges et d'Ã©viter que deux obstacles ne se
  // succÃ¨dent trop rapidement.  Cette valeur plus Ã©levÃ©e est rÃ©duite
  // progressivement avec le score.
  // La valeur prÃ©cÃ©dente (300) a Ã©tÃ© jugÃ©e trop faible suite Ã  la mise Ã  jour
  // : un dÃ©lai plus long (360 frames) procure des obstacles mieux espacÃ©s
  // et une meilleure lisibilitÃ©.
  const initialSpawnInterval = 360;
  let spawnInterval = initialSpawnInterval;

  // -------------------------------------------------------------------------
  // Gestion de la vitesse indÃ©pendante du nombre de frames
  //
  // speedFactor reprÃ©sente le multiplicateur de vitesse global calculÃ© dans
  // config.js via window.getGameSpeed('flappy').  Il est utilisÃ© pour
  // convertir les intervalles dÃ©finis en nombre de frames en intervalles
  // tempsâ€‘rÃ©el.  Ã€ chaque frame, nous incrÃ©mentons des minuteries avec
  // speedFactor et dÃ©clenchons des Ã©vÃ©nements (apparition dâ€™obstacles,
  // nuages ou oiseaux) lorsque ces minuteries dÃ©passent un seuil.
  let speedFactor = 1;
  function applySpeedFactor() {
    try {
      if (window.getGameSpeed) {
        const s = window.getGameSpeed('flappy');
        speedFactor = (typeof s === 'number' && s > 0) ? s : 1;
      } else {
        speedFactor = 1;
      }
    } catch (e) {
      speedFactor = 1;
    }
  }
  // Initialiser speedFactor et mettre Ã  jour lorsqu'un nouvel FPS est mesurÃ©
  applySpeedFactor();
  window.addEventListener('capySpeedUpdated', applySpeedFactor);

  // Timers cumulÃ©s pour contrÃ´ler les apparitions dâ€™obstacles, nuages et oiseaux
  let obstacleTimer = 0;
  let cloudTimer = 0;
  let birdTimer = 0;

  // -------------------------------------------------------------------------
  // Palettes de couleurs pour les obstacles naturels
  //
  // Afin de remplacer les tuyaux rectangulaires par des Ã©lÃ©ments
  // organiques (arbres et rochers), nous dÃ©finissons ici des palettes
  // harmonieuses et pastel.  Chaque entrÃ©e de tableau est choisie pour
  // apporter de la variÃ©tÃ© tout en restant douce pour lâ€™Å“il.  Les couleurs
  // sont inspirÃ©es des tons des forÃªts et des roches sous un ciel ensoleillÃ©.
  //
  // TREE_TRUNK_COLORS : dÃ©finit un dÃ©gradÃ© vertical pour les troncs dâ€™arbre.
  // Chaque objet comporte une couleur `top` et `bottom` pour la partie
  // supÃ©rieure et infÃ©rieure du tronc.  Les nuances sont lÃ©gÃ¨rement
  // rosÃ©es et brunes.
  const TREE_TRUNK_COLORS = [
    { top: '#d7ccc8', bottom: '#bcaaa4' },
    { top: '#bcaaa4', bottom: '#a1887f' },
    { top: '#a1887f', bottom: '#8d6e63' }
  ];
  // TREE_CANOPY_COLORS : couleur unique pour la canopÃ©e de chaque arbre.
  // Les verts sont tendres et lÃ©gÃ¨rement jaunis pour rappeler des feuilles
  // baignÃ©es de lumiÃ¨re.
  const TREE_CANOPY_COLORS = ['#c5e1a5', '#aed581', '#b9f6ca'];
  // ROCK_COLORS : couleur de base pour un bloc rocheux stylisÃ©.  Les teintes
  // gris-bleutÃ©es sont volontairement douces pour conserver la cohÃ©rence
  // avec le reste de la palette.
  const ROCK_COLORS = ['#cfd8dc', '#b0bec5', '#90a4ae'];
  // ROCK_LUMP_COLORS : couleur des reliefs dessinÃ©s par-dessus les rochers.
  // LÃ©gÃ¨rement plus foncÃ© pour suggÃ©rer la profondeur.
  const ROCK_LUMP_COLORS = ['#b0bec5', '#90a4ae', '#78909c'];

  /**
   * Applique le multiplicateur de vitesse dÃ©fini dans config.js.  Cette
   * fonction est appelÃ©e au dÃ©marrage et Ã  chaque fois que la vitesse
   * globale est mise Ã  jour (Ã©vÃ©nement capySpeedUpdated).  Elle recalcule
   * gameSpeed et spawnInterval Ã  partir des valeurs originales.
   */
  function applySpeed() {
    try {
      if (window.getGameSpeed) {
        const spd = window.getGameSpeed('flappy');
        gameSpeed = origGameSpeed * spd;
        // Utiliser un intervalle minimal plus Ã©levÃ© (320) afin d'espacer
        // davantage les obstacles.  Le facteur dÃ©pend du multiplicateur
        // global de vitesse spd, mais ne descend jamais en dessous de 320
        // frames.  Ceci corrige le comportement trop rapide observÃ© aprÃ¨s
        // l'actualisation automatique de la vitesse.
        spawnInterval = Math.max(320, Math.round(initialSpawnInterval / spd));
      }
    } catch (e) {
      // en cas d'erreur, conserver les valeurs actuelles
    }
  }
  // Appliquer la vitesse au chargement
  applySpeed();
  // Recalculer la vitesse lorsque l'Ã©vÃ©nement capySpeedUpdated est envoyÃ©
  window.addEventListener('capySpeedUpdated', applySpeed);
  let frameCount = 0;
  let score = 0;
  // Timer d'animation du score.  Lorsqu'un point est gagnÃ©, ce compteur
  // est initialisÃ© Ã  une valeur positive afin de dÃ©clencher un effet
  // d'agrandissement temporaire sur le compteur affichÃ© en haut de l'Ã©cran.
  // Le compteur est dÃ©crÃ©mentÃ© Ã  chaque frame dans update() via la logique
  // d'affichage et ne devient jamais nÃ©gatif.
  let scoreAnimationTimer = 0;
  let invincibleTimer = 0;

  // Hauteur du sol en bas de l'Ã©cran (portion rÃ©servÃ©e au dÃ©cor)
  // Hauteur du sol (bande horizontale en bas de l'Ã©cran).  Dans
  // FlyingÂ Capi, le sol n'est plus visible afin de renforcer la
  // sensation de vol.  Nous initialisons donc cette valeur Ã  0.
  let groundHeight = 0;

  // Nuages et oiseaux pour le fond
  const clouds = [];
  const birds = [];

  // Mettre Ã  jour les textes affichant les meilleurs scores sur la page d'accueil.
  function updateMenuScores() {
    if (bestScoreFlappyEl) {
      bestScoreFlappyEl.textContent = `Record FlyingÂ CapyÂ : ${highScore}`;
    }
    if (bestScoreRunningEl) {
      bestScoreRunningEl.textContent = `Record RunningÂ CapyÂ : ${runnerHighScore}`;
    }
    if (bestScoreEnergyEl) {
      bestScoreEnergyEl.textContent = `Record RagonÂ Ã©lectriqueÂ : ${energyHighScore}`;
    }
  }


  // Context audio pour les effets sonores
  const AudioContext = window.AudioContext || window.webkitAudioContext;
  let audioCtx;
  try {
    audioCtx = new AudioContext();
  } catch (e) {
    audioCtx = null;
  }

  function playBeep(frequency, duration = 0.1, volume = 0.1) {
    if (!audioCtx || isMuted) return;
    // Lâ€™AudioContext sur mobile ne dÃ©marre quâ€™aprÃ¨s une interaction utilisateur
    const ctx = audioCtx;
    const osc = ctx.createOscillator();
    const gain = ctx.createGain();
    osc.frequency.value = frequency;
    osc.type = 'square';
    gain.gain.value = volume;
    osc.connect(gain);
    gain.connect(ctx.destination);
    const now = ctx.currentTime;
    osc.start(now);
    osc.stop(now + duration);
  }

  // Gestion du son
  // Lorsque isMuted est vrai, tous les sons (effets et ambiance) sont coupÃ©s.
  let isMuted = false;

  // Audio ambiant du mode Flappy.  Ce fichier est un bruit blanc vide qui
  // pourra Ãªtre remplacÃ© par une vraie ambiance par l'utilisateur.  La
  // lecture boucle automatiquement.
  const ambient = new Audio('assets/sounds/ambient_flappy.wav');
  ambient.loop = true;

  // Appliquer immÃ©diatement le volume global Ã  l'ambiance.
  applyVolume();

  /**
   * Calcule le volume global enregistrÃ© par le menu.  Valeur comprise entre
   * 0 et 1.  Retourne 0,5 par dÃ©faut si aucune valeur n'est stockÃ©e.
   */
  function getGlobalVolume() {
    let v = 0.5;
    try {
      const stored = localStorage.getItem('capyGlobalVolume');
      if (stored !== null) v = parseFloat(stored);
    } catch (e) {
      /* ignore */
    }
    return isNaN(v) ? 0.5 : v;
  }

  /**
   * Met Ã  jour le volume de l'audio ambiant et de tous les effets sonores
   * (dÃ©finis plus loin) en fonction de isMuted et du volume global.
   */
  function applyVolume() {
    const vol = isMuted ? 0 : getGlobalVolume();
    ambient.volume = vol;
    // Les effets sonores utilisent playBeep, qui rÃ¨gle son volume dans la
    // fonction playBeep directement.
  }

  /**
   * Lance la musique d'ambiance du jeu.  Si le son est coupÃ©, ne joue
   * rien.  L'audio se met en boucle jusqu'Ã  l'appel de stopMusic().
   */
  function startMusic() {
    applyVolume();
    if (!isMuted) {
      try {
        ambient.currentTime = 0;
        ambient.play();
      } catch (e) {
        /* ignore */
      }
    }
  }

  /**
   * ArrÃªte l'ambiance en la mettant en pause.  Utiliser pause() Ã©vite
   * certains bugs de Chrome oÃ¹ stop() rÃ©initialise l'audio.  
   */
  function stopMusic() {
    try {
      ambient.pause();
    } catch (e) {
      /* ignore */
    }
  }

  // Classe Capybara reprÃ©sentant le joueur
  class Capybara {
    constructor() {
      this.x = width * 0.25;
      this.y = height / 2;
      this.radius = 25;
      // Dimensions adaptÃ©es au nouveau visuel PNG (capybara ailÃ©).  Afin de
      // rendre le hÃ©ros plus imposant Ã  lâ€™Ã©cran, la largeur et la hauteur
      // sont augmentÃ©es.  Ces valeurs correspondent Ã  environ +25Â % par
      // rapport aux dimensions prÃ©cÃ©dentes.
      // Agrandir le hÃ©ros pour qu'il soit plus visible
      this.width = 130;
      this.height = 100;
      this.velY = 0;
      this.rotation = 0;
      // Timer dâ€™animation des ailes.  Plus la valeur est grande, plus
      // l'animation est lente.  Nous l'initialisons Ã  zÃ©ro ici et
      // l'utiliserons pour dÃ©clencher des battements progressifs.
      this.wingFlapTimer = 0;
      // Timer de glisseÂ : lorsque >0, la chute est ralentie pour simuler un vol planÃ©
      this.glideTimer = 0;
    }
    reset() {
      this.y = height / 2;
      this.velY = 0;
      this.rotation = 0;
      this.wingFlapTimer = 0;
      // DÃ©buter avec une courte phase de planÃ©.  La version prÃ©cÃ©dente
      // permettait de planer longtemps, ce qui donnait l'impression que
      // le capybara Ã©tait un avion.  Nous rÃ©duisons cette durÃ©e Ã 
      // environ 0,5Â s (30Â frames) pour un dÃ©marrage moins flottant.
      this.glideTimer = 30;
    }
    update() {
      // Lorsque la glisse est active, appliquer une accÃ©lÃ©ration trÃ¨s faible et limiter la vitesse.
      if (this.glideTimer > 0) {
        // Pendant le planÃ©, appliquer une accÃ©lÃ©ration faible.  La version
        // prÃ©cÃ©dente multipliait la gravitÃ© par 0,05 (donc la chute Ã©tait
        // extrÃªmement lente).  Pour que le capybara ne plane plus comme un
        // avion en papier, on applique 30Â % de la gravitÃ©.
        this.velY += gravity * 0.3;
        this.glideTimer--;
        // Limiter la vitesse de descente afin que le capybara tombe trÃ¨s lentement.
        if (this.velY > 1) {
          this.velY = 1;
        }
        // Limiter Ã©galement la remontÃ©e pour Ã©viter un saut trop abrupt si plusieurs clics sont rapides.
        if (this.velY < -3) {
          this.velY = -3;
        }
      } else {
        // Hors planÃ©, appliquer la gravitÃ© normale.
        this.velY += gravity;
      }
      this.y += this.velY;
      // Mettre Ã  jour la rotation en fonction de la vitesse (pour lâ€™animation de lâ€™inertie)
      const rotMax = 0.5;
      const rotMin = -0.5;
      this.rotation = Math.max(rotMin, Math.min(rotMax, this.velY / 10));
      // DÃ©crÃ©menter le timer dâ€™animation des ailes
      if (this.wingFlapTimer > 0) {
        this.wingFlapTimer--;
      }
    }
    jump() {
      // Impulsion rÃ©duiteÂ : on ne monte pas trop haut pour faciliter la gestion de lâ€™altitude.
      // Ce saut initial est couplÃ© Ã  une phase de planÃ© qui ralentit fortement la descente.
      // Ajuster encore lâ€™impulsion vers le hautÂ : on monte lÃ©gÃ¨rement moins haut.
      // Augmenter lâ€™impulsion du saut afin de rendre le hÃ©ros plus rÃ©actif.
      // Une valeur plus nÃ©gative le propulse plus vite vers le haut, amÃ©liorant
      // ainsi la maniabilitÃ©.  La valeur prÃ©cÃ©dente (-4.2) rendait le capybara
      // trop lent Ã  contrÃ´ler aprÃ¨s la derniÃ¨re mise Ã  jour.
      this.velY = -6;
      // Activer la phase de glisse pendant un temps trÃ¨s court.  RÃ©duire
      // drastiquement la durÃ©e permet d'Ã©viter un planÃ© prolongÃ©.  Ã€ 60Â FPS,
      // 5Â frames reprÃ©sentent environ 0,08Â s.
      this.glideTimer = 5;
      playBeep(600, 0.05, 0.08);
      // DÃ©clencher lâ€™animation des ailes pendant la durÃ©e du planÃ© pour un battement visible
      this.wingFlapTimer = 25;
    }
    draw() {
      ctx.save();
      ctx.translate(this.x, this.y);
      ctx.rotate(this.rotation);
      // Utiliser le sprite PNG transparent du capybara si disponible, sinon un ovale de secours
      if (capyImg.complete && capyImg.naturalWidth) {
        ctx.drawImage(
          capyImg,
          -this.width / 2,
          -this.height / 2,
          this.width,
          this.height
        );
      } else {
        ctx.fillStyle = '#b99563';
        ctx.beginPath();
        ctx.ellipse(0, 0, this.width / 2, this.height / 2, 0, 0, Math.PI * 2);
        ctx.fill();
      }
      // Les ailes ont Ã©tÃ© retirÃ©es pour simplifier le design de FlyingÂ Capy.
      // Aucune animation supplÃ©mentaire n'est dessinÃ©e derriÃ¨re le sprite.
      ctx.restore();
    }
      /*
       * Les Ã©lÃ©ments suivants dessinaient autrefois l'oreille, l'Å“il, la narine,
       * les pattes et la queue pour la version vectorielle du capybara.
       * Maintenant que nous utilisons un sprite PNG complet, nous n'avons
       * plus besoin de ces formes supplÃ©mentaires. Elles sont conservÃ©es
       * ici Ã  titre de rÃ©fÃ©rence mais dÃ©sactivÃ©es.
       *
       * ctx.fillStyle = '#8b6c47';
       * ctx.beginPath();
       * ctx.ellipse(this.width * 0.18, -this.height * 0.38, this.width * 0.12, this.height * 0.18, 0, 0, Math.PI * 2);
       * ctx.fill();
       * // Å’il
       * ctx.fillStyle = '#fff';
       * ctx.beginPath();
       * ctx.ellipse(this.width * 0.46, -this.height * 0.12, this.width * 0.08, this.height * 0.1, 0, 0, Math.PI * 2);
       * ctx.fill();
       * ctx.fillStyle = '#000';
       * ctx.beginPath();
       * ctx.ellipse(this.width * 0.48, -this.height * 0.12, this.width * 0.03, this.height * 0.04, 0, 0, Math.PI * 2);
       * ctx.fill();
       * // Narine repositionnÃ©e vers l'avant
       * ctx.fillStyle = '#4d3928';
       * ctx.beginPath();
       * ctx.ellipse(this.width * 0.64, -this.height * 0.05, this.width * 0.03, this.height * 0.04, 0, 0, Math.PI * 2);
       * ctx.fill();
       * // Pattes
       * ctx.fillStyle = '#8b6c47';
       * ctx.fillRect(-this.width * 0.25, this.height * 0.45, this.width * 0.15, this.height * 0.22);
       * ctx.fillRect(this.width * 0.05, this.height * 0.45, this.width * 0.15, this.height * 0.22);
       * // Queue
       * ctx.beginPath();
       * ctx.arc(-this.width * 0.45, 0, this.width * 0.08, 0, Math.PI * 2);
       * ctx.fill();
      */
      // Ancienne restauration obsolÃ¨te supprimÃ©e.
    getBounds() {
      // RÃ©duire la boÃ®te de collision pour Ãªtre plus permissifÂ :
      // seule la partie centrale du corps compte pour les collisions.
      const shrink = 0.8;
      return {
        left: this.x - (this.width * shrink) / 2,
        top: this.y - (this.height * shrink) / 2,
        right: this.x + (this.width * shrink) / 2,
        bottom: this.y + (this.height * shrink) / 2
      };
    }
  }

  // Classe Obstacle
  class Obstacle {
    constructor() {
      this.width = 60;
      this.x = width + this.width;
      // Hauteur du trou dynamiqueÂ : large au dÃ©but, se rÃ©duit lorsque le score augmente
      // Taille du trouÂ : trÃ¨s large au dÃ©but pour faciliter le passage, se rÃ©duit lentement avec le score
      const maxGap = 420;
      const minGap = 260;
      // RÃ©duction trÃ¨s progressive pour ne pas fermer trop rapidement
      // On retire 0,5 pixel du trou par point de score, afin de garder des ouvertures larges plus longtemps.
      this.gapHeight = Math.max(minGap, maxGap - score * 0.5);
      // Position verticale du centre du trou
      // S'assurer que le trou ne chevauche pas le sol (groundHeight)
      const margin = 50;
      const availableHeight = height - groundHeight - margin * 2 - this.gapHeight;
      this.gapY = Math.random() * availableHeight + margin + this.gapHeight / 2;
      // Ajuster la position verticale du trou en fonction du trou prÃ©cÃ©dent pour
      // garantir une progression fluide entre deux obstacles.  Si le trou
      // prÃ©cÃ©dent existe, limiter le dÃ©calage vertical Ã  une valeur
      // raisonnable.  Le capybara peut ainsi franchir chaque passage sans
      // devoir effectuer des montÃ©es ou descentes impossibles.
      if (lastGapY !== null) {
        const maxShift = 200; // diffÃ©rence maximale en pixels entre deux passages
        // Calculer les bornes autorisÃ©es pour gapY
        const lowerBound = margin + this.gapHeight / 2;
        const upperBound = height - groundHeight - margin - this.gapHeight / 2;
        if (this.gapY > lastGapY + maxShift) {
          this.gapY = Math.min(lastGapY + maxShift, upperBound);
        } else if (this.gapY < lastGapY - maxShift) {
          this.gapY = Math.max(lastGapY - maxShift, lowerBound);
        }
      }
      // Mettre Ã  jour la derniÃ¨re hauteur afin que l'obstacle suivant puisse s'y rÃ©fÃ©rer
      lastGapY = this.gapY;
      this.scored = false;
      // Bonus associÃ© (peut Ãªtre null)
      this.bonus = null;
      // GÃ©nÃ©ration dâ€™un bonus avec une faible probabilitÃ©
      if (Math.random() < 0.25) {
        const bonusType = Math.random() < 0.5 ? 'score' : 'invincible';
        const bonusX = this.x + this.width / 2;
        const bonusY = this.gapY;
        this.bonus = new Bonus(bonusX, bonusY, bonusType);
      }

      // Choisir alÃ©atoirement le type d'obstacle parmi 'tree' ou 'rock'.  Ces
      // valeurs dÃ©terminent la maniÃ¨re dont l'obstacle est dessinÃ© dans
      // draw().  Un indice de variante est Ã©galement gÃ©nÃ©rÃ© pour varier
      // les palettes de couleurs des troncs, des feuillages et des rochers.
      this.type = Math.random() < 0.5 ? 'tree' : 'rock';
      this.variant = Math.floor(Math.random() * 3);
    }
    update() {
      this.x -= gameSpeed;
      if (this.bonus) {
        this.bonus.x -= gameSpeed;
      }
    }
    draw() {
      // Dessiner des tuyaux classiques de style FlappyÂ Bird au lieu
      // d'obstacles stylisÃ©s.  Chaque obstacle se compose de deux
      // sections rectangulaires (haut et bas) sÃ©parÃ©es par un trou.
      // On ajoute un embout lÃ©gÃ¨rement plus large pour Ã©voquer la
      // terminaison du tuyau.
      const topHeight = this.gapY - this.gapHeight / 2;
      const bottomY = this.gapY + this.gapHeight / 2;
      const bottomHeight = (height - groundHeight) - bottomY;
      if (topHeight > 0) {
        this.drawPipeSection(this.x, 0, this.width, topHeight, true);
      }
      if (bottomHeight > 0) {
        this.drawPipeSection(this.x, bottomY, this.width, bottomHeight, false);
      }
      // Dessiner le bonus, s'il existe, au-dessus des tuyaux
      if (this.bonus) {
        this.bonus.draw();
      }
    }

    /**
     * Dessine une section de tuyau.  Le tuyau se compose d'un corps
     * rectangulaire et d'un embout plus large pour rappeler le design
     * original.  Pour le haut du trou, l'embout est dessinÃ© en bas
     * (face vers le bas)Â ; pour le bas du trou, il est dessinÃ© en haut.
     * @param {number} x Position horizontale du tuyau
     * @param {number} y Position verticale de dÃ©but de la section
     * @param {number} w Largeur du tuyau (hors embout)
     * @param {number} h Hauteur de la section
     * @param {boolean} isTop Indique si la section est au-dessus du trou
     */
    drawPipeSection(x, y, w, h, isTop) {
      // Couleurs inspirÃ©es de FlappyÂ BirdÂ : un vert moyen pour le corps
      // et un vert plus clair pour l'embout.  Un vert plus foncÃ© est
      // utilisÃ© pour le contour afin de crÃ©er un lÃ©ger relief.
      const bodyColor = '#6ec85f';
      const capColor = '#8ade71';
      const borderColor = '#499d3b';
      const capHeight = Math.min(20, h * 0.2);
      // Corps du tuyau (zone principale)
      ctx.fillStyle = bodyColor;
      ctx.fillRect(x, y, w, h);
      // Embout : lÃ©gÃ¨rement plus large que le corps
      const capY = isTop ? (y + h - capHeight) : y;
      ctx.fillStyle = capColor;
      ctx.fillRect(x - 5, capY, w + 10, capHeight);
      // Contours du corps
      ctx.lineWidth = 2;
      ctx.strokeStyle = borderColor;
      ctx.strokeRect(x, y, w, h);
      // Contours de l'embout
      ctx.strokeRect(x - 5, capY, w + 10, capHeight);
    }
    isOffScreen() {
      return this.x + this.width < 0;
    }
  }

  // Classe Bonus
  class Bonus {
    constructor(x, y, type) {
      this.x = x;
      this.y = y;
      // Bonus plus grand pour Ãªtre plus facilement collectÃ©
      this.radius = 24;
      this.type = type; // 'score' ou 'invincible'
      this.collected = false;
    }
    draw() {
      ctx.save();
      ctx.translate(this.x, this.y);
      // Dessiner une bulle semiâ€‘transparente autour du bonus pour le
      // mettre en Ã©vidence. La bulle est lÃ©gÃ¨rement plus lumineuse pour
      // attirer davantage l'Å“il du joueur.
      ctx.fillStyle = 'rgba(255, 236, 105, 0.35)';
      ctx.beginPath();
      ctx.arc(0, 0, this.radius * 1.5, 0, Math.PI * 2);
      ctx.fill();
      // Dessiner une carotte ou une patate au lieu d'une Ã©toile. La
      // carotte pointe vers le bas et possÃ¨de des fanes vertes au sommet.
      if (this.type === 'score') {
        // Carotte avec une couleur orange plus vive et un tracÃ©
        // lÃ©gÃ¨rement plus large. La pointe de la carotte est orientÃ©e
        // vers le bas (la racine), tandis que le sommet est Ã©largi. Les
        // coordonnÃ©es tiennent compte du systÃ¨me de coordonnÃ©es Canvas
        // (l'axe y croÃ®t vers le bas).
        ctx.fillStyle = '#f6a323';
        ctx.beginPath();
        // Pointe dirigÃ©e vers le bas
        ctx.moveTo(0, this.radius);
        ctx.lineTo(this.radius * 0.6, -this.radius);
        ctx.lineTo(-this.radius * 0.6, -this.radius);
        ctx.closePath();
        ctx.fill();
        // Fanes vertes au sommet : trois petites pointes
        ctx.fillStyle = '#6ea84f';
        const leafCount = 3;
        for (let i = 0; i < leafCount; i++) {
          ctx.beginPath();
          const lx = (-this.radius * 0.25) + i * (this.radius * 0.25);
          ctx.moveTo(lx, -this.radius * 1.05);
          ctx.lineTo(lx + this.radius * 0.15, -this.radius * 1.3);
          ctx.lineTo(lx + this.radius * 0.3, -this.radius * 1.05);
          ctx.closePath();
          ctx.fill();
        }
      } else {
        // Patate avec une couleur plus chaude
        ctx.fillStyle = '#d7a26c';
        ctx.beginPath();
        ctx.ellipse(0, 0, this.radius, this.radius * 0.8, 0, 0, Math.PI * 2);
        ctx.fill();
        // Taches sur la peau
        ctx.fillStyle = '#aa7342';
        for (let i = 0; i < 4; i++) {
          const angle = (i * Math.PI * 2) / 4;
          const px = Math.cos(angle) * this.radius * 0.4;
          const py = Math.sin(angle) * this.radius * 0.3;
          ctx.beginPath();
          ctx.ellipse(px, py, this.radius * 0.1, this.radius * 0.07, 0, 0, Math.PI * 2);
          ctx.fill();
        }
      }
      ctx.restore();
    }
  }

  // Variables globales
  let capy = new Capybara();
  let obstacles = [];
  // Conserver la derniÃ¨re position verticale du trou des obstacles pour
  // Ã©viter que deux passages consÃ©cutifs ne soient trop Ã©loignÃ©s.
  // Lorsque null, aucune contrainte n'est appliquÃ©e.
  let lastGapY = null;

  // Classe Cloud pour le dÃ©cor de fond
  class Cloud {
    constructor() {
      this.reset();
    }
    reset() {
      this.y = Math.random() * (height - groundHeight) * 0.4;
      this.x = width + Math.random() * width;
      this.speed = 0.5 + Math.random() * 0.5;
      this.scale = 0.6 + Math.random() * 0.6;
    }
    update() {
      // DÃ©placer le nuage vers la gauche.  Multiplier par speedFactor
      // afin que la vitesse soit indÃ©pendante du nombre de frames et
      // conserve une allure constante sur les diffÃ©rents Ã©crans.
      this.x -= this.speed * speedFactor;
      if (this.x < -150 * this.scale) {
        this.reset();
        this.x = width;
      }
    }
    draw() {
      ctx.save();
      ctx.fillStyle = 'rgba(255,255,255,0.8)';
      ctx.translate(this.x, this.y);
      const r = 30 * this.scale;
      // Dessiner trois cercles qui se chevauchent pour former un nuage
      ctx.beginPath();
      ctx.arc(-r * 0.6, 0, r, 0, Math.PI * 2);
      ctx.arc(0, -r * 0.4, r * 1.2, 0, Math.PI * 2);
      ctx.arc(r * 0.8, 0, r, 0, Math.PI * 2);
      ctx.fill();
      ctx.restore();
    }
  }

  // Classe Bird
  // ReprÃ©sente un petit oiseau stylisÃ© en forme de V dans le ciel.  Les
  // oiseaux se dÃ©placent plus rapidement que les nuages pour donner
  // l'impression d'un dÃ©filement dynamique.  Ils sont utilisÃ©s dans
  // l'arriÃ¨reâ€‘plan du mode volant pour apporter de la vie mÃªme lorsqu'il
  // n'y a pas d'obstacles Ã  l'Ã©cran.
  class Bird {
    constructor() {
      this.x = width + 30;
      this.y = Math.random() * (height - groundHeight) * 0.4 + 20;
      // Vitesse lÃ©gÃ¨rement plus Ã©levÃ©e que celle des nuages
      this.speed = gameSpeed * 0.5 + Math.random() * 1.0;
    }
    update() {
      // DÃ©placement horizontal de l'oiseau.  Le facteur speedFactor
      // garantit une vitesse constante indÃ©pendamment du taux de
      // rafraÃ®chissement.
      this.x -= this.speed * speedFactor;
    }
    draw() {
      ctx.save();
      ctx.strokeStyle = '#5d4037';
      ctx.lineWidth = 2;
      ctx.beginPath();
      // Dessiner un simple V pour reprÃ©senter un oiseau
      ctx.moveTo(this.x, this.y);
      ctx.lineTo(this.x + 6, this.y - 4);
      ctx.lineTo(this.x + 12, this.y);
      ctx.stroke();
      ctx.restore();
    }
    isOffScreen() {
      return this.x < -20;
    }
  }

  function resetGame() {
    score = 0;
    frameCount = 0;
    invincibleTimer = 0;
    // Vitesse initiale lÃ©gÃ¨rement plus rapide pour dynamiser le dÃ©filement
    gameSpeed = 1.6;
    // Espacement initial trÃ¨s large
    spawnInterval = initialSpawnInterval;
    // RÃ©initialiser la mÃ©moire du dernier trou afin que le premier
    // obstacle du niveau puisse apparaÃ®tre n'importe oÃ¹.
    lastGapY = null;
    obstacles = [];
    // RÃ©initialiser les nuages et les oiseaux
    clouds.length = 0;
    birds.length = 0;
    capy.reset();
  }

  function update() {
    // Mettre Ã  jour les nuages et les oiseaux de fond lorsque le jeu est en cours.
    if (state === STATE_PLAYING) {
      // Ajouter de nouveaux nuages pÃ©riodiquement en fonction du facteur de vitesse.
      // Le timer cloudTimer s'incrÃ©mente de speedFactor Ã  chaque frame.  Lorsque
      // cloudTimer dÃ©passe 300, un nuage est ajoutÃ© et le timer est rÃ©duit.
      cloudTimer += speedFactor;
      if (cloudTimer >= 300) {
        cloudTimer -= 300;
        clouds.push(new Cloud());
      }
      clouds.forEach((c) => c.update());
      // Ajouter des oiseaux occasionnellement.  La probabilitÃ© par frame est
      // multipliÃ©e par speedFactor pour assurer une frÃ©quence constante
      // d'apparition par seconde sur tous les Ã©crans.
      if (Math.random() < 0.02 * speedFactor) {
        birds.push(new Bird());
      }
      birds.forEach((b) => b.update());
      // Supprimer les oiseaux sortis de l'Ã©cran pour Ã©viter une accumulation
      for (let i = birds.length - 1; i >= 0; i--) {
        if (birds[i].isOffScreen()) {
          birds.splice(i, 1);
        }
      }
    }
    frameCount++;
    // Mise Ã  jour du capybara
    capy.update();
    // EmpÃªcher de sortir de lâ€™Ã©cran (collision avec le sol ou le plafond)
    if (capy.y + capy.height / 2 >= height - groundHeight) {
      capy.y = height - groundHeight - capy.height / 2;
      capy.velY = 0;
      endGame();
    } else if (capy.y - capy.height / 2 <= 0) {
      capy.y = capy.height / 2;
      capy.velY = 0;
    }
    // GÃ©rer lâ€™invincibilitÃ©
    if (invincibleTimer > 0) {
      invincibleTimer--;
    }
    // GÃ©nÃ©ration pÃ©riodique des obstacles.  Au lieu de se baser sur
    // frameCount, on utilise un compteur temporel.  Ã€ chaque frame,
    // obstacleTimer est incrÃ©mentÃ© de speedFactor.  Lorsqu'il atteint ou
    // dÃ©passe spawnInterval, un nouvel obstacle est crÃ©Ã© et le compteur
    // est rÃ©duit.  Cette approche maintient un rythme constant
    // d'apparition d'obstacles, quelle que soit la frÃ©quence de
    // rafraÃ®chissement.
    obstacleTimer += speedFactor;
    if (obstacleTimer >= spawnInterval) {
      obstacleTimer -= spawnInterval;
      obstacles.push(new Obstacle());
    }
    // Mise Ã  jour et suppression des obstacles hors Ã©cran
    for (let i = obstacles.length - 1; i >= 0; i--) {
      const obs = obstacles[i];
      obs.update();
      // ScoreÂ : lorsquâ€™un obstacle est passÃ© Ã  gauche du capybara
      if (!obs.scored && obs.x + obs.width < capy.x) {
        obs.scored = true;
        score++;
        // DÃ©clencher l'animation du score.  La valeur 15 correspond Ã 
        // environ un quart de seconde Ã  60Â FPS.  Cette durÃ©e permet un
        // agrandissement visible mais bref du compteur afin d'attirer
        // l'attention du joueur lorsqu'il franchit un obstacle.
        scoreAnimationTimer = 15;
        // Augmenter progressivement la vitesse toutes les 8 unitÃ©s de score.
        // Avant 50Â points, augmentation modÃ©rÃ©eÂ ; auâ€‘delÃ  de 50Â points, la vitesse augmente davantage.
        if (score % 8 === 0) {
          if (score < 50) {
            gameSpeed += 0.1;
          } else {
            gameSpeed += 0.15;
          }
        }
        // RÃ©duire lâ€™intervalle de gÃ©nÃ©ration en fonction du score pour rapprocher les obstacles.
        // Ajuster lâ€™intervalle de gÃ©nÃ©ration en fonction du score.  Nous
        // utilisons une valeur plancher plus Ã©levÃ©e (320) et une rÃ©duction
        // plus lente afin dâ€™Ã©viter que les obstacles nâ€™arrivent trop vite.
        spawnInterval = Math.max(320, Math.floor(initialSpawnInterval - score * 0.12));
        playBeep(400, 0.05, 0.05);
      }
      // DÃ©tection de collision obstacle
      const bounds = capy.getBounds();
      // Collision horizontale
      if (
        bounds.right > obs.x &&
        bounds.left < obs.x + obs.width
      ) {
        // VÃ©rifier verticalement
        const gapTop = obs.gapY - obs.gapHeight / 2;
        const gapBottom = obs.gapY + obs.gapHeight / 2;
        if (
          bounds.top < gapTop ||
          bounds.bottom > gapBottom
        ) {
          if (invincibleTimer <= 0) {
            endGame();
          }
        }
      }
      // DÃ©tection de bonus : si le capybara entre en collision avec le bonus,
      // ajouter les points ou l'invincibilitÃ© et supprimer le bonus pour
      // qu'il disparaisse immÃ©diatement.
      if (obs.bonus && !obs.bonus.collected) {
        const dx = capy.x - obs.bonus.x;
        const dy = capy.y - obs.bonus.y;
        const dist = Math.sqrt(dx * dx + dy * dy);
        if (dist < capy.width / 2 + obs.bonus.radius) {
          if (obs.bonus.type === 'score') {
            score += 5;
          } else {
            invincibleTimer = 300; // environ 5 secondes Ã  60Â FPS
          }
          playBeep(800, 0.1, 0.08);
          // Marquer comme collectÃ© et supprimer le bonus pour qu'il disparaisse
          obs.bonus.collected = true;
          obs.bonus = null;
        }
      }
      if (obs.isOffScreen()) {
        obstacles.splice(i, 1);
      }
    }
  }

  /**
   * Dessine lâ€™arriÃ¨reâ€‘planÂ : ciel en dÃ©gradÃ©, nuages flottants et sol herbeux.
   */
  function drawBackground() {
    // Ciel dÃ©gradÃ©
    const skyGrad = ctx.createLinearGradient(0, 0, 0, height - groundHeight);
    skyGrad.addColorStop(0, '#bbdefb');
    skyGrad.addColorStop(1, '#e3f2fd');
    ctx.fillStyle = skyGrad;
    ctx.fillRect(0, 0, width, height - groundHeight);
    // Nuages
    clouds.forEach((c) => c.draw());
    // Oiseaux en arriÃ¨reâ€‘plan
    birds.forEach((b) => b.draw());
    // Sol : utiliser un motif Ã  partir d'une image pour remplacer le fond vert.
    // Si l'image est chargÃ©e, l'Ã©tirer sur toute la largeur du jeu.  Dans le
    // cas contraire, dessiner un dÃ©gradÃ© beige pour Ã©viter un fond vert.
    if (groundImg.complete && groundImg.naturalWidth) {
      ctx.drawImage(groundImg, 0, height - groundHeight, width, groundHeight);
    } else {
      const groundGrad = ctx.createLinearGradient(0, height - groundHeight, 0, height);
      groundGrad.addColorStop(0, '#f0e5d0');
      groundGrad.addColorStop(1, '#d2b48c');
      ctx.fillStyle = groundGrad;
      ctx.fillRect(0, height - groundHeight, width, groundHeight);
    }
  }

  function draw() {
    // Effacer lâ€™Ã©cran
    ctx.clearRect(0, 0, width, height);
    // Dessiner le fond (ciel, nuages et sol)
    drawBackground();
    // Dessiner les obstacles
    obstacles.forEach((obs) => obs.draw());
    // Si invincible, dessiner un halo autour du capybara
    if (invincibleTimer > 0) {
      ctx.save();
      ctx.globalAlpha = 0.5;
      ctx.fillStyle = '#ffe082';
      ctx.beginPath();
      ctx.ellipse(capy.x, capy.y, capy.width * 0.7, capy.height * 0.8, 0, 0, Math.PI * 2);
      ctx.fill();
      ctx.restore();
    }
    // Dessiner le capybara
    capy.draw();
    // Score courant au centre du haut.  On affiche uniquement le nombre,
    // dans une police dorÃ©e et en gras, avec une boÃ®te semiâ€‘transparente
    // pour amÃ©liorer la lisibilitÃ© sur le ciel et les obstacles.
    ctx.save();
    ctx.font = 'bold 28px Arial';
    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';
    const scoreStr = String(Math.floor(score));
    const metrics = ctx.measureText(scoreStr);
    const pad = 12;
    const boxW = metrics.width + pad * 2;
    const boxH = 38;
    const boxX = (width - boxW) / 2;
    const boxY = 6;
    ctx.fillStyle = 'rgba(0,0,0,0.4)';
    ctx.fillRect(boxX, boxY, boxW, boxH);
    ctx.fillStyle = '#FFD700';
    ctx.fillText(scoreStr, width / 2, boxY + boxH / 2);
    // Afficher l'indication d'invincibilitÃ© sous le score si nÃ©cessaire
    if (invincibleTimer > 0) {
      ctx.font = '16px Arial';
      ctx.fillStyle = '#ffeb3b';
      ctx.fillText('InvincibilitÃ©', width / 2, boxY + boxH + 18);
    }
    ctx.restore();
  }

  function endGame() {
    state = STATE_GAMEOVER;
    // Mettre Ã  jour le meilleur score
    if (score > highScore) {
      highScore = score;
      try {
        localStorage.setItem('flappyCapybaraHighScore', String(highScore));
      } catch (e) {
        // Ignore stockage
      }
    }
    // Afficher uniquement la valeur du score et du record dans l'Ã©cran de fin
    currentScoreEl.textContent = `${score}`;
    highScoreEl.textContent = `${highScore}`;
    // Ajouter un visuel et un message humoristique.  Pour les scores
    // infÃ©rieurs Ã  10, utiliser un message satirique pour souligner la
    // performance modeste du joueur.  Sinon, sÃ©lectionner une
    // anecdote fromagÃ¨re.
    if (funMessageEl) {
      let msg;
      if (score < 10) {
        msg = lowScoreMessages[Math.floor(Math.random() * lowScoreMessages.length)];
      } else {
        msg = cheeseMessages[Math.floor(Math.random() * cheeseMessages.length)];
      }
      const imgSrc = funImages[Math.floor(Math.random() * funImages.length)];
      funMessageEl.innerHTML = `<img src="${imgSrc}"> <span>${msg}</span>`;
    }
    gameOverOverlay.classList.remove('hidden');
    playBeep(200, 0.2, 0.15);
    // ArrÃªter la musique d'ambiance lorsque la partie se termine
    stopMusic();
  }

  function gameLoop() {
    // Ne pas exÃ©cuter le jeu tant que la popâ€‘up de prÃ©â€‘lancement est visible
    if (window.CAPY_PRESTART_ACTIVE) {
      requestAnimationFrame(gameLoop);
      return;
    }
    if (state === STATE_PLAYING) {
      update();
      draw();
    }
    requestAnimationFrame(gameLoop);
  }

  // DÃ©marrage du jeu depuis le menu
  function startGame() {
    resetGame();
    state = STATE_PLAYING;
    // Masquer l'Ã©cran de menu et l'Ã©cran de fin si prÃ©sents.  Sur la page
    // flappy.html, le menu n'existe pas et ces lignes sont donc sans effet.
    if (menuOverlay) menuOverlay.classList.add('hidden');
    if (gameOverOverlay) gameOverOverlay.classList.add('hidden');
    // DÃ©marrer la musique d'ambiance pour le mode volant
    startMusic();
  }

  // Lorsque l'overlay de prÃ©â€‘lancement se ferme, un Ã©vÃ©nement "capyGameStart"
  // est envoyÃ© par config.js.  Sur les pages oÃ¹ FlyingÂ Capy se lance
  // automatiquement (flappy.html), il faut dÃ©marrer la partie Ã  ce
  // momentâ€‘lÃ  car il n'y a pas de bouton Â«Â playÂ Â».  La condition
  // STATE_MENU garantit que l'on ne redÃ©marre pas une partie en cours.
  window.addEventListener('capyGameStart', () => {
    if (state === STATE_MENU) {
      startGame();
    }
  });

  // Par sÃ©curitÃ©, lancer la partie automatiquement aprÃ¨s 2,5Â s si
  // l'Ã©vÃ©nement n'est jamais reÃ§u (par exemple si config.js n'est pas
  // chargÃ© ou qu'un bug empÃªche l'Ã©mission de capyGameStart).  Ce
  // dÃ©lai garantit que le jeu dÃ©marre toujours.
  setTimeout(() => {
    if (state === STATE_MENU) {
      startGame();
    }
  }, 2500);
  function returnMenu() {
    state = STATE_MENU;
    // Afficher l'Ã©cran de menu si prÃ©sent et masquer l'Ã©cran de fin
    if (menuOverlay) menuOverlay.classList.remove('hidden');
    if (gameOverOverlay) gameOverOverlay.classList.add('hidden');
    // Mettre Ã  jour les textes de meilleurs scores lors du retour au menu principal
    updateMenuScores();
    // ArrÃªter la musique d'ambiance lorsque l'on retourne au menu
    stopMusic();
  }

  // Listeners boutons.  VÃ©rifier l'existence de chaque Ã©lÃ©ment avant de lui
  // attacher un gestionnaire d'Ã©vÃ©nement afin d'Ã©viter une erreur si l'Ã©lÃ©ment
  // n'est pas prÃ©sent sur la page (c'est le cas de flappy.html).
  if (playBtn) {
    playBtn.addEventListener('click', () => {
      startGame();
    });
  }
  if (replayBtn) {
    replayBtn.addEventListener('click', () => {
      startGame();
    });
  }
  if (menuBtn) {
    menuBtn.addEventListener('click', () => {
      // Sur la page de jeu autonome (flappy.html), il n'y a pas d'Ã©cran de menuÂ ;
      // dans ce cas on retourne Ã  la page d'accueil.  Sinon on affiche le menu interne.
      if (!menuOverlay) {
        // Lorsque l'Ã©cran de jeu autonome (par ex. flappy.html) est affichÃ©, revenir
        // au menu principal situÃ© un niveau auâ€‘dessus.  Sans ce prÃ©fixe, le chemin
        // est interprÃ©tÃ© comme capy/Capy/games.html.
        window.location.href = '../Capy/games.html';
      } else {
        returnMenu();
      }
    });
  }
  if (runnerBtn) {
    runnerBtn.addEventListener('click', () => {
      window.location.href = 'runner.html';
    });
  }
  // Bouton pour accÃ©der au mode Ragondin VÃ©hicule.  Redirige vers la page dÃ©diÃ©e.
  const energyBtn = document.getElementById('energy-button');
  if (energyBtn) {
    energyBtn.addEventListener('click', () => {
      window.location.href = 'energy.html';
    });
  }

  // ContrÃ´les de jeu (clic/touch ou barre espace)
  function handleJump(e) {
    if (state === STATE_PLAYING) {
      capy.jump();
    } else if (state === STATE_MENU) {
      startGame();
    }
  }
  canvas.addEventListener('mousedown', handleJump);
  canvas.addEventListener('touchstart', (e) => {
    e.preventDefault();
    handleJump();
  });
  window.addEventListener('keydown', (e) => {
    if (e.code === 'Space' || e.code === 'ArrowUp') {
      handleJump();
    }
  });

  // Adapter le canvas Ã  la taille de la fenÃªtre
  function resizeCanvas() {
    const ratio = 480 / 640;
    const windowRatio = window.innerWidth / window.innerHeight;
    if (windowRatio > ratio) {
      // Largeur trop grande, ajuster largeur
      const newHeight = window.innerHeight;
      const newWidth = newHeight * ratio;
      canvas.width = newWidth;
      canvas.height = newHeight;
    } else {
      const newWidth = window.innerWidth;
      const newHeight = newWidth / ratio;
      canvas.width = newWidth;
      canvas.height = newHeight;
    }
    // Appliquer la taille de style pour permettre le centrage horizontal via margin auto
    canvas.style.width = `${canvas.width}px`;
    canvas.style.height = `${canvas.height}px`;
    width = canvas.width;
    height = canvas.height;
    // Le jeu volant ne nÃ©cessite pas d'afficher le solÂ : conserver un sol nul
    groundHeight = 0;
    // Mettre Ã  jour capybara pour quâ€™il reste proportionnel (Ã  ce stade on garde la taille)
  }
  window.addEventListener('resize', resizeCanvas);
  resizeCanvas();

  // Afficher les meilleurs scores dans le menu au chargement
  updateMenuScores();

  // Pour la page flappy.html il n'y a pas de bouton play.  Nous ne
  // dÃ©marrons plus immÃ©diatement la partie afin de laisser aux
  // ressources le temps de se charger.  Le dÃ©marrage est dÃ©sormais
  // dÃ©clenchÃ© par l'Ã©vÃ©nement "capyGameStart" (gÃ©rÃ© dans config.js) ou
  // par le fallback ciâ€‘dessus (setTimeout).  Nous masquons
  // simplement les overlays s'ils existent pour Ã©viter qu'ils
  // apparaissent par erreur.
  if (!playBtn) {
    if (menuOverlay) menuOverlay.classList.add('hidden');
    if (gameOverOverlay) gameOverOverlay.classList.add('hidden');
    // Ne pas lancer startGame iciÂ ; il sera dÃ©clenchÃ© automatiquement
    // lorsque l'Ã©vÃ©nement capyGameStart sera Ã©mis ou aprÃ¨s le dÃ©lai
    // spÃ©cifiÃ© dans setTimeout ciâ€‘dessus.
  }

  // Lancer la boucle de jeu
  requestAnimationFrame(gameLoop);
})();
